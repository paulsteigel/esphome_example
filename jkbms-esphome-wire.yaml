# JK-BMS-CAN ( PYLON, Seplos, GoodWe, SMA and Victron CAN bus protocol )

# esp32_wire_jk-bms-can.yaml is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/gpl.html>.
# V1.16.6 paulsteigel : copy and revised current limit for charging control from most updated version by Sleeper85 and Mr.Pablo
# https://github.com/Sleeper85/esphome-jk-bms-can/blob/main/ESP32_LFP_Wire_jk-bms-can.yaml V1.17.5
# V1.16.5 paulsteigel : Adding limitation for discharging/charging when cell voltage reach limit and SOC was incorrectly calculated!
# V1.16.4 Sleeper85 : Improved Charging Logic for ESP32 startup/reboot and Float charge, Add CAN ID 0x356 bytes [06:07] cycles for Sofar, Change switch name
# V1.16.3 Sleeper85 : ID 0x379 will be sent when choosing protocol 2 or 4 (Battery Capacity for Victron, Sol-Ark and Luxpower)
# V1.16.2 Sleeper85 : Split the "Charge/Discharge values" section and added instructions for "Stop Discharging" + Set "esp-idf" framework by default
# V1.16.1 Sleeper85 : Slider charging_current max value = ${charge_a}, Improved Alarm/Charging/Discharging Logic, Improved CAN protocol and Victron support
# V1.15.5 Sleeper85 : Improved code and set api "reboot_timout" to "0s" by default (no reboot without HA)
# V1.15.4 Sleeper85 : Improved documentation for API, Web Server and WiFi settings
# V1.15.3 Sleeper85 : Add 'CAN Protocol Settings' and new CAN ID based on the SMA and Victron protocol (alpha)
# V1.15.2 Sleeper85 : Improved Alarm handling, all alarms will set charge/discharge current to 0A and set 'Charging Status' to Alarm
# V1.15.1 Sleeper85 : New CANBUS script with CANBUS Status in HA, stop sending CAN messages if the inverter is not responding (fix WDT reboot issues)
# V1.14.3 Sleeper85 : Improved documentation + Charging Voltage tips for Deye
# V1.14.2 Sleeper85 : Improve 'Charging Voltage' behavior
# V1.14.1 Sleeper85 : Add 'Float charge function'
# V1.13.6 Sleeper85 : Add 'Absorption time' and 'Absorption Offset V.' slider
# V1.13.5 Sleeper85 : Set CAN manufacter to "PYLON" for improve compatibility with Deye and other inverters
# V1.13.4 Sleeper85 : Improve 'Charge Status' behavior + add 'Rebulk Offset V.' slider
# V1.13.3 uksa007   : Improve compatibility with Deye and other inverters
# V1.13.2 uksa007   : Send Max Temperature of T1, T2 to inverter
# V1.13.1 uksa007   : Fix compile issues with new version of ESPhome 2023.4.0, set rebulk offset to 2.5

substitutions:
# +--------------------------------------+
# name that will appear in esphome and homeassistant.
  name: [put your device name here]
  
# +--------------------------------------+
# Number of Battery modules max 8. Each LX U5.4-L battery is 5.4kWh, select the number closest to your capactiy eg 3.2V * 280Ah * 16 = 14.3kWh
  batt_modules: "1"
# +--------------------------------------+
# | Battery Charge Settings              |
# +--------------------------------------+
# Tips for Deye inverter : Add 0.1v to the settings below because the Deye charging voltage is always 0.1v lower than requested.
# Float V. : 53.7v              (3.35v/cell - Natural voltage of a fully charged cell at rest, I advise you not to go higher.)
# Absorption V : 55.3v          (3.45v/cell - It's not necessary to use a charging voltage higher than 55.2V for a full charge.)
# Absorption Offset V. : 0.15v  (The absorption phase will start at 55.15v (BMS voltage). Warning: the BMS voltage must be correctly calibrated.)
# +--------------------------------------+
# This is max charging amps eg 100A, for Bulk - Constant Current charging(CC), should be at least 10A less than BMS change current protection, 0.5C max
# 100A * 50V = 5000W
  charge_a: "30"

  # by Mr. Pablo Factor to control the end of the charge current curve. A setting below 2 will extend the curve, above 2 will shorten the curve. 
  charge_a_factor_curve_end: "2.0"
  discharge_a_factor_curve_end: "2.0"
  # A factor above 1 will reduce current at a fast rate after the float voltage is reached, then slow as a cell reaches the BMS "cell_voltage_overvoltage_recovery".
  charge_a_factor_curve_shape: "1.8"
  discharge_knee_v: "3.1"
# Float Voltage : corresponds to the voltage at which the battery would be maintained at the end of the absorption phase. (53.6v eg 3.35v/cell for 16 cells 48V battery)
  float_v: "53.6"
# Absorption Voltage : corresponds to the Bulk voltage that will be used to charge the battery. (55.2v eg 3.45v/cell for 16 cells 48V battery)
  absorption_v: "55.2"
# Absorption time in minutes to hold charge voltage after charge voltage is reached eg 30
  absorption_time: "30"
# Absorption offset, x Volts below absorption voltage battery will start the absorption timer, eg 55.2-0.05 = 52.15v
  absorption_offset_v: "0.05"
# Rebulk offset, x Volts below absorption voltage battery will request rebulk, eg 55.2-2.5 = 52.7v
  rebulk_offset_v: "2.5"
# +--------------------------------------+
# | Battery Discharge Settings           |
# +--------------------------------------+
# Max discharge amps eg 120, should be at least 10A less than BMS over discharge current protection, 0.5C max
# 120A * 50V = 6000W
  discharge_a: "50"
# Minimum discharge voltage eg 48v/16 = 3V per cell
  min_discharge_v: "48"
# +--------------------------------------+
# | Battery State of Health (SOH)        |
# +--------------------------------------+
# Maximum charging cycles is used to calculate the battey SOH, LF280K v3 =8000.0, LF280K v2 =6000.0, LF280=3000.0 (decimal is required)
  max_cycles: "6000.0"
# +--------------------------------------+
# | CAN Protocol Settings                |
# +--------------------------------------+
# CAN BMS Name (0x35E) : 0 NoSent / 1 PYLON / 2 GOODWE / 3 SEPLOS
  can_bms_name: "1"
# CAN Protocol
# 1 : PYLON 1.2 (Deye)
# 2 : SEPLOS 1.0, PYLON 1.3, GOODWE 1.5 (GoodWe, Sol-Ark, Luxpower)
# 3 : SMA (Sunny Island, Sofar)
# 4 : VICTRON
  can_protocol: "1"
# +--------------------------------------+
# | ESP32 CAN/serial port pins           |
# +--------------------------------------+
# GPIO pins your CAN bus transceiver(TJA1050) is connected to the ESP, note! TX->TX and RX->RX. 
  can_tx_pin: GPIO16
  can_rx_pin: GPIO17
# GPIO pins your JK-BMS RS485(TTL) is connected to the ESP TX->RX and RX->TX. 
  tx_pin: GPIO9
  rx_pin: GPIO10
# --------------------------------------

# +------------------------------------------------------------------+
# | ** The settings below can be modified according to your needs ** |
# +------------------------------------------------------------------+
  external_components_source: github://syssi/esphome-jk-bms@main
  # components
  # github://syssi/esphome-jk-bms@main  
  
esphome:
  name: ${name}
#  on_boot:
#    then:
#      - switch.turn_on: switch_charging
#      - switch.turn_on: switch_discharging
#      - switch.turn_on: switch_chg_float
    
# +--------------------------------------+
# | ESP32 settings                       |
# +--------------------------------------+
# For a stable Bluetooth connection keep the "esp-idf" framework
esp32:
  board: lolin_s2_mini
#  board: esp32doit-devkit-v1
#  framework:
#    type: esp-idf

external_components:
  - source: ${external_components_source}
    refresh: 0s
  - source: github://pr#5586
    components: [ ota_http ]

logger:
  level: INFO


# Please use the native `api` component instead of the `mqtt` section.
# If you use Home Assistant, the native API is more lightweight.
# If there is no HA server connected to this API, the ESP32 reboots every 15 minutes to try to resolve the problem.
# If you don't use Home Assistant please uncomment the "reboot_timeout: 0s" option.
#api:
#  reboot_timeout: 0s

# If you don't want to use ESPHome's native API you can use MQQT instead.
# In this case don't forget to remove the 'api:' section.
mqtt:
  broker: [address for your mqtt broker]
  username: mqtt_user
  password: [password for mqtt]
  client_id: ${name}_mqtt

# In the event of problems with the WiFi network, the ESP32 will reboot every 15 minutes to try to resolve the problem.
# If we don't want to connect the ESP32 to the WiFi network please remove the 4 lines below.
wifi:
  # Public host/IP that this ESPHome device can be reached on
  use_address: ${name}.ddns.net
  ap:
    ssid: "ESP32S2Lolin"
#    password: !secret wifi_ap_password

captive_portal:

# will soon be replaced with ota_http by @Olivier Archer to enjoy remote update
ota:
  password: [your OTA password here]
  # Forward this TCP port to do OTA updates remotely
  port: 8266

http_request:
  id: http_data

ota_http:
  exclude_certificate_bundle: true
button:
  - platform: template
    name: "${name} Firmware update"
    on_press:
      then:
        - ota_http.flash:
            md5_url: https://xyz.com/Metafiles/${name}.md5
            url: https://xyz.com/Metafiles/${name}.bin
        - logger.log: "This message should be not displayed (reboot)"
#web_server:
#  port: 80
#  log: false
#  ota: false

# +--------------------------------------+
# | ** Don't make changes below this **  |
# +--------------------------------------+

globals:
  - id: can_ack_counter
    type: int
    restore_value: no
    initial_value: '0'
  - id: charge_status
    type: std::string
    restore_value: no
    initial_value: '"Wait"'
  - id: can_status
    type: std::string
    restore_value: no
    initial_value: '"OFF"'
  - id: alarm_status
    type: std::string
    restore_value: no
    initial_value: '"NoAlarm"'
  - id: charging_v
    type: float
    restore_value: no
    initial_value: '0.0'

# these are global variables for controlling the overall charge/discharge  
  - id: report_soc
    type: uint16_t
    restore_value: no
    initial_value: '0'  
  - id: charging_a
    type: int
    restore_value: no
    initial_value: '0'
  - id: discharging_a
    type: int
    restore_value: no
    initial_value: '0'
  - id: can_msg_counter
    type: int
    restore_value: no
    initial_value: '0'
  - id: previous_current
    type: int
    restore_value: no
    initial_value: '0'
  - id: last_current_change
    type: int
    restore_value: no
    initial_value: '0'
  
output:
  - platform: gpio
    pin: 15
    id: led
    inverted: true

light:
  - platform: binary
    output: led
    id: blue_led
    name: "Blue LED"
    internal: true

# +--------------------------------------+
# | JK-BMS UART connection               |
# +--------------------------------------+

uart:
  id: uart_0
  baud_rate: 115200
  rx_buffer_size: 384
  tx_pin: ${tx_pin}
  rx_pin: ${rx_pin}
#  debug:
#    direction: BOTH

jk_modbus:
  id: modbus0
  uart_id: uart_0

jk_bms:
  id: bms0
  jk_modbus_id: modbus0
  # enable_fake_traffic: true

# +--------------------------------------+

binary_sensor:
  - platform: jk_bms
    balancing:
      name: "${name} balancing"
    balancing_switch:
      name: "${name} balancing switch"
    charging:
      name: "${name} charging"
    charging_switch:
      id: charging_switch
      name: "${name} charging switch"
    discharging:
      name: "${name} discharging"
    discharging_switch:
      id: discharging_switch
      name: "${name} discharging switch"
    dedicated_charger_switch:
      name: "${name} dedicated charger switch"

sensor:
  - platform: jk_bms
    min_cell_voltage:
      id: min_cell_voltage
      name: "${name} min cell voltage"
    max_cell_voltage:
      id: max_cell_voltage
      name: "${name} max cell voltage"
    min_voltage_cell:
      id: min_voltage_cell
      name: "${name} min voltage cell"
    max_voltage_cell:
      id: max_voltage_cell
      name: "${name} max voltage cell"
    delta_cell_voltage:
      name: "${name} delta cell voltage"
    average_cell_voltage:
      name: "${name} average cell voltage"
    cell_voltage_1:
      name: "${name} cell voltage 1"
    cell_voltage_2:
      name: "${name} cell voltage 2"
    cell_voltage_3:
      name: "${name} cell voltage 3"
    cell_voltage_4:
      name: "${name} cell voltage 4"
    cell_voltage_5:
      name: "${name} cell voltage 5"
    cell_voltage_6:
      name: "${name} cell voltage 6"
    cell_voltage_7:
      name: "${name} cell voltage 7"
    cell_voltage_8:
      name: "${name} cell voltage 8"
    cell_voltage_9:
      name: "${name} cell voltage 9"
    cell_voltage_10:
      name: "${name} cell voltage 10"
    cell_voltage_11:
      name: "${name} cell voltage 11"
    cell_voltage_12:
      name: "${name} cell voltage 12"
    cell_voltage_13:
      name: "${name} cell voltage 13"
    cell_voltage_14:
      name: "${name} cell voltage 14"
    cell_voltage_15:
      name: "${name} cell voltage 15"
    cell_voltage_16:
      name: "${name} cell voltage 16"
#    cell_voltage_17:
#      name: "${name} cell voltage 17"
#    cell_voltage_18:
#      name: "${name} cell voltage 18"
#    cell_voltage_19:
#      name: "${name} cell voltage 19"
#    cell_voltage_20:
#      name: "${name} cell voltage 20"
#    cell_voltage_21:
#      name: "${name} cell voltage 21"
#    cell_voltage_22:
#      name: "${name} cell voltage 22"
#    cell_voltage_23:
#      name: "${name} cell voltage 23"
#    cell_voltage_24:
#      name: "${name} cell voltage 24"
    power_tube_temperature:
      id: power_tube_temperature
      name: "${name} power tube temperature"
    temperature_sensor_1:
      id: temperature_sensor_1
      name: "${name} temperature sensor 1"
    temperature_sensor_2:
      id: temperature_sensor_2
      name: "${name} temperature sensor 2"
    total_voltage:
      id: total_voltage
      name: "${name} total voltage"
    current:
      id: current
      name: "${name} current"
    power:
      name: "${name} power"
    charging_power:
      name: "${name} charging power"
    discharging_power:
      name: "${name} discharging power"
    capacity_remaining:
      id: capacity_remaining
      name: "${name} capacity remaining"
    capacity_remaining_derived:
      id: capacity_remaining_derived
      name: "${name} capacity remaining derived"
    temperature_sensors:
      name: "${name} temperature sensors"
    charging_cycles:
      id: charging_cycles
      name: "${name} charging cycles"
    total_charging_cycle_capacity:
      id: total_charging_cycle_capacity
      name: "${name} total charging cycle capacity"
    battery_strings:
      id: battery_strings 
      name: "${name} battery strings"
    errors_bitmask:
      id: errors_bitmask
      name: "${name} errors bitmask"
    operation_mode_bitmask:
      name: "${name} operation mode bitmask"
    total_voltage_overvoltage_protection:
      name: "${name} total voltage overvoltage protection"
    total_voltage_undervoltage_protection:
      name: "${name} total voltage undervoltage protection"
    cell_voltage_overvoltage_protection:
      name: "${name} cell voltage overvoltage protection"
    cell_voltage_overvoltage_recovery:
      name: "${name} cell voltage overvoltage recovery"
    cell_voltage_overvoltage_delay:
      name: "${name} cell voltage overvoltage delay"
    cell_voltage_undervoltage_protection:
      name: "${name} cell voltage undervoltage protection"
    cell_voltage_undervoltage_recovery:
      name: "${name} cell voltage undervoltage recovery"
    cell_voltage_undervoltage_delay:
      name: "${name} cell voltage undervoltage delay"
    cell_pressure_difference_protection:
      name: "${name} cell pressure difference protection"
    discharging_overcurrent_protection:
      name: "${name} discharging overcurrent protection"
    discharging_overcurrent_delay:
      name: "${name} discharging overcurrent delay"
    charging_overcurrent_protection:
      name: "${name} charging overcurrent protection"
    charging_overcurrent_delay:
      name: "${name} charging overcurrent delay"
    balance_starting_voltage:
      name: "${name} balance starting voltage"
    balance_opening_pressure_difference:
      name: "${name} balance opening pressure difference"
    power_tube_temperature_protection:
      name: "${name} power tube temperature protection"
    power_tube_temperature_recovery:
      name: "${name} power tube temperature recovery"
    temperature_sensor_temperature_protection:
      name: "${name} temperature sensor temperature protection"
    temperature_sensor_temperature_recovery:
      name: "${name} temperature sensor temperature recovery"
    temperature_sensor_temperature_difference_protection:
      name: "${name} temperature sensor temperature difference protection"
    charging_high_temperature_protection:
      name: "${name} charging high temperature protection"
    discharging_high_temperature_protection:
      name: "${name} discharging high temperature protection"
    charging_low_temperature_protection:
      name: "${name} charging low temperature protection"
    charging_low_temperature_recovery:
      name: "${name} charging low temperature recovery"
    discharging_low_temperature_protection:
      name: "${name} discharging low temperature protection"
    discharging_low_temperature_recovery:
      name: "${name} discharging low temperature recovery"
    total_battery_capacity_setting:
      id: total_battery_capacity_setting
      name: "${name} total battery capacity setting"
    current_calibration:
      name: "${name} current calibration"
    device_address:
      name: "${name} device address"
    sleep_wait_time:
      name: "${name} sleep wait time"
    alarm_low_volume:
      name: "${name} alarm low volume"
    manufacturing_date:
      name: "${name} manufacturing date"
    total_runtime:
      name: "${name} total runtime"
    # start_current_calibration:
    #   name: "${name} start current calibration"
    actual_battery_capacity:
      name: "${name} actual battery capacity"
    # protocol_version:
    #   name: "${name} protocol version"
  # +--------------------------------------+
  # | Uptime sensor                        |
  # +--------------------------------------+
  - platform: uptime
    name: ${name} Uptime Sensor
    id: uptime_sensor
    update_interval: 60s
    on_raw_value:
      then:
        - text_sensor.template.publish:
            id: uptime_human
            state: !lambda |-
              int seconds = round(id(uptime_sensor).raw_state);
              int days = seconds / (24 * 3600);
              seconds = seconds % (24 * 3600);
              int hours = seconds / 3600;
              seconds = seconds % 3600;
              int minutes = seconds /  60;
              seconds = seconds % 60;
              return (
                (days ? to_string(days) + "d " : "") +
                (hours ? to_string(hours) + "h " : "") +
                (minutes ? to_string(minutes) + "m " : "") +
                (to_string(seconds) + "s")
              ).c_str();

# copy from Sleeper85 code for easy handling max/min cell problem 
# First, an initial charge current is calculated based upon the maximum cell voltage but only if the Auto Charge Current switch is enabled.
  - platform: copy
    source_id: min_cell_voltage
    name: "${name} Discharge current limit"
    id: "${name}_discharge_current_limit"
    unit_of_measurement: A
    device_class: current
    internal: true  
    filters:
    - lambda: !lambda |-
        // Auto Discharge Current function
        // map the charging current to the max cell voltage rising
        
        int temp_cur = id(discharging_current).state;
        if (id(can_switch_auto_discharge_current).state) {
          if (id(min_cell_voltage).state * 1000 <= id(can_under_voltage_protection).state + 100) {
            temp_cur = map(id(min_cell_voltage).state * 1000, id(can_under_voltage_protection).state + 30, id(can_under_voltage_protection).state - 10, id(discharging_current).state, 0);        
          }
        }
        
        id(discharging_a) = temp_cur;                                 
        return temp_cur;        
        
  - platform: copy
    source_id: max_cell_voltage
    name: "${name} Charge current limit"
    id: "${name}_charge_current_limit"
    unit_of_measurement: A
    device_class: current
    internal: true  
    filters:
    - lambda: !lambda |-
        
        double cell_float_v = id(float_voltage).state;
        float temp_cur = 0.0;        
        // map the charging current to the max cell voltage rising
        temp_cur = id(charging_current).state;
        if (id(max_cell_voltage).state * 1000 <= (id(can_over_voltage_protection).state -20)) {          
            //temp_cur = max(0.0,(- pow(${charge_a_factor_curve_end}, pow( max(0.0, ((x - cell_float_v) / (id(can_over_voltage_protection).state - cell_float_v))),${charge_a_factor_curve_shape}))+2) * id(charging_current).state);
            int temp_cur_x = map(id(max_cell_voltage).state * 1000, id(can_over_voltage_protection).state - 100, id(can_over_voltage_protection).state + 10, id(charging_current).state * 10, 0.0);
            temp_cur = float(temp_cur_x) / 10;
            // do not recover back to high current too quickly
            if (id(previous_current) <= temp_cur_x) {                            
              if (millis() - id(last_current_change) > 60 * 1000) {
                // reduce current immediately to the map() value
                id(last_current_change) = millis();
                id(previous_current) = temp_cur_x;
              } else {
                // reduce current immediately to the last_current_change
                temp_cur = float(id(previous_current)) / 10;
              }
            }  
          } 
        
        id(charging_a) = temp_cur;                      
        return temp_cur;
  
  - platform: copy
    source_id: capacity_remaining
    name: "${name} capacity_remaining"
    id: "${name}_capacity_remaining"
    unit_of_measurement: "%"
    device_class: battery
    internal: true  
    filters:
    - lambda: !lambda |-        
        uint16_t max_cell_voltage_i = id(max_cell_voltage).state * 1000.0;
        uint16_t min_cell_voltage_i = id(min_cell_voltage).state * 1000.0;
        uint16_t soc = id(capacity_remaining).state;                      
        
        if (soc >= 98) {
          if (max_cell_voltage_i  <= id(can_over_voltage_protection).state) soc = 98; //keep soc at this level till OVP reached
        } else {
          if (min_cell_voltage_i < id(can_under_voltage_protection).state){
            // reached lowest voltage level set by user inform inverter to stop discharge
            id(discharging_a) = 0;
            soc = id(can_soc_stop_discharging).state;
            ESP_LOGI("main", "SOC problem remained x x:", soc, id(capacity_remaining).state);
          } else if (id(capacity_remaining).state <= id(can_soc_stop_discharging).state) { 
            soc = id(can_soc_stop_discharging).state + 1; // keep it at a level that inverter will not stop discharging
            //soc = map(id(max_cell_voltage).state, id(can_over_voltage_protection).state - 100, id(can_over_voltage_protection).state + 10, 90, 99);
            //soc = constrain(tmp_soc, 90, 99);
          } else soc = uint16_t(id(capacity_remaining).state);
        }
        id(report_soc) = soc;                      
        return soc;

text_sensor:
  - platform: jk_bms
    errors:
      name: "${name} errors"
    operation_mode:
      name: "${name} operation mode"
    battery_type:
      name: "${name} battery type"
    password:
      name: "${name} password"
    device_type:
      name: "${name} device type"
    software_version:
      name: "${name} software version"
    manufacturer:
      name: "${name} manufacturer"
    total_runtime_formatted:
      name: "${name} total runtime formatted"
  # +--------------------------------------+
  # | Template text sensors                |
  # +--------------------------------------+
  - platform: template
    name: ${name} Uptime Human Readable
    id: uptime_human
    icon: mdi:clock-start
  - platform: template
    name: "${name} Charging Status"
    id: charging_status
  - platform: template
    name: "${name} CANBUS Status"
    id: canbus_status
# +--------------------------------------+
# | Slider                               |
# +--------------------------------------+
number:
  # use bulk voltage base on cell to avoid problem for 15 cells battery type
  - platform: template
    name: "${name} Bulk voltage"
    id: "bulk_voltage"
    step: 10
    min_value: 3450
    max_value: 3650
    mode: slider
    initial_value: 3450
    unit_of_measurement: mV
    icon: mdi:battery-charging
    optimistic: true
    restore_value: true
    entity_category: config    
    

  - platform: template
    name: "${name} Float voltage"
    id: "float_voltage"
    step: 10
    min_value: 3400
    max_value: 3500
    mode: slider
    initial_value: 3400
    unit_of_measurement: mV
    icon: mdi:battery-charging
    optimistic: true
    restore_value: true
    entity_category: config
    

  - platform: template
    name: "${name} Charging current max"
    id: "charging_current"
    step: 1
    min_value: 0
    max_value: "${charge_a}"
    #mode: slider
    initial_value: "${charge_a}"
    unit_of_measurement: A
    icon: mdi:current-dc
    optimistic: true
    restore_value: true
    entity_category: config
    

  - platform: template
    name: "${name} Discharging current max"
    id: "discharging_current"
    step: 1
    min_value: 0
    max_value: "${discharge_a}"
    #mode: slider
    initial_value: "${discharge_a}"
    unit_of_measurement: A
    icon: mdi:current-dc
    optimistic: true
    restore_value: true
    entity_category: config           

# this for setting time to stop the floating charge, no need to apply absorption charging 
  - platform: template
    name: "${name} Absorption time"
    id: "absorption_time"
    step: 1
    min_value: 0
    max_value: 180
    #mode: slider
    initial_value: "${absorption_time}"
    unit_of_measurement: min
    icon: mdi:clock-start
    optimistic: true
    restore_value: true
    entity_category: config

# this for helping to calculate the proper current seding to the inverter    
  - platform: template
    name: "${name} Parrallel packs's capacity (Ah)"
    id: "parrallel_packs_capacity_ah"
    step: 1
    min_value: 0
    max_value: 480
    mode: slider
    initial_value: 0
    unit_of_measurement: Ah
    icon: mdi:sine-wave
    optimistic: true
    restore_value: true    
    entity_category: config 

  - platform: template
    name: "${name} Over voltage protection"
    id: "can_over_voltage_protection"
    step: 5
    min_value: 3380
    max_value: 3450
    mode: slider
    initial_value: 3400
    unit_of_measurement: mV
    icon: mdi:sine-wave
    optimistic: true
    restore_value: true
    entity_category: config    

  - platform: template
    name: "${name} Under voltage protection CAN bus"
    id: "can_under_voltage_protection"
    step: 10
    min_value: 3100
    max_value: 3200
    mode: slider
    initial_value: 3150
    unit_of_measurement: mV
    icon: mdi:sine-wave
    optimistic: true
    restore_value: true
    entity_category: config    
           
  
  - platform: template
    name: "${name} Stop discharging SOC"
    id: "can_soc_stop_discharging"
    step: 1
    min_value: 10
    max_value: 50
    mode: slider
    initial_value: 20
    icon: mdi:battery-20
    optimistic: true
    restore_value: true
    entity_category: config    
    
  
  - platform: template
    id: "number_demo"
    name: "${name} Template number"
    optimistic: true
    min_value: 0
    max_value: 100
    step: 0.5
    mode: box
    entity_category: config
  
# +--------------------------------------+
script:
# for checking charging/discharging parammeters  
  - id: limit_check_script
    then:
      # Read current SOC and other parameters
      - lambda: |-
          // Global variables to be use across the app, the script will calculate those variables 
          // can_bus will send these out only, no need calculation elsewhere
          //id(charging_a)
          //id(dis_charging_a)
          //id(charging_v) = id(bulk_voltage).state;
          //soc = uint16_t(id(capacity_remaining).state);
          
          id(discharging_a) = id(discharging_a) - 1; // reduce current by 1A
          id(charging_current).state = 15;
          // We applied a constant charging voltage
          id(charging_v) = id(bulk_voltage).state;
          
          // get these values from the BMS for checking
          uint16_t max_cell_voltage_i = id(max_cell_voltage).state * 1000.0;
          uint16_t min_cell_voltage_i = id(min_cell_voltage).state * 1000.0;                      
          
          id(report_soc) = uint16_t(id(capacity_remaining).state);
          id(charging_v) = id(bulk_voltage).state * id(battery_strings).state;
          id(charging_a) = 15;//id(charging_current).state;
          id(discharging_a) = id(discharging_current).state;
          id(switch_discharging).state = true;
          id(switch_charging).state = true;

          //ESP_LOGI("main", "Enter checking script : %s", id(charging_current).state); 
          // Check if charging
          if (int16_t(id(current).state) > 0) {
            // Check SOC and max cell voltage for charging control
            if (id(report_soc) > 80 && max_cell_voltage_i <= (uint16_t(id(can_over_voltage_protection).state) - 50)) {
              // Report 98% SOC to keep charging till reaching OVP
              id(report_soc) = 80;
            } else if (max_cell_voltage_i >= (uint16_t(id(can_over_voltage_protection).state) - 50) && id(charging_a) > 1) {
              // Reduce charging current limit by 1 Ampere, when the max_cell_voltage almost reached the OVP level
              id(charging_a) -= 1;
            } else if (id(charging_a) <= 1 && max_cell_voltage_i >= uint16_t(id(can_over_voltage_protection).state)) {              
              // Stop charging
              id(report_soc) = 100;
              id(charge_status) = "EOC";              
              // Recover charging current limit to the beginning value set by the user
              id(charging_a) = id(charging_current).state;
            } else {
              //leave charging goes with initial setting, we may have to set this here. like voltage/current              
              id(charging_v) = id(bulk_voltage).state * id(battery_strings).state;
              id(charging_a) = 15;//id(charging_current).state;
              id(discharging_a) = id(discharging_current).state;
              id(switch_discharging).state = true;
              id(switch_charging).state = true;
              ESP_LOGI("main", "Normal charging applied: %s Ampere", id(charging_a));                                        
            }
          }
          
          // Check if discharging
          if (int16_t(id(current).state) < 0) {
            // Check SOC and min cell voltage for discharging control: 50mV is the safe voltage range to process
            if (id(report_soc) <= id(can_soc_stop_discharging).state && (min_cell_voltage_i >= (uint16_t(id(can_under_voltage_protection).state) + 50))) {
              // Continue discharging, report the stoping soc to avoid case that BMS SOC fall to 0 falsely and make inveter stop discharging
              id(report_soc) = id(can_soc_stop_discharging).state;
            } else if (abs(min_cell_voltage_i - uint16_t(id(can_over_voltage_protection).state) < 50) && id(discharging_a) > 1.0) {
              // Reduce discharging current limit by 1 Ampere automatically and in some cases might go to 0 for stop.
              id(discharging_a) -= 1.0;
            } else if (min_cell_voltage_i <= uint16_t(id(can_under_voltage_protection).state)) {
              // Stop discharging as min cell voltage fell below the UVP
              id(discharging_a) = 0;
              id(report_soc) = id(can_soc_stop_discharging).state;
            }
          }

switch:
  - platform: template
    name: "${name} CAN Charge enabled"
    id: switch_charging
    optimistic: true
  - platform: template
    name: "${name} CAN Discharge enabled"
    id: switch_discharging
    optimistic: true
  - platform: template
    name: "${name} CAN Force bulk (top bal)"
    id: switch_chg_bulk
    optimistic: true
  - platform: template
    name: "${name} CAN Float charge enabled"
    id: switch_chg_float
    optimistic: true
  - platform: restart
    id: btn_restart
    name: "Restart_ESP"
  - platform: template
    name: ${name} CAN Automatic Charge Current
    id: can_switch_auto_charge_current
    optimistic: true
    entity_category: config  
  - platform: template
    name: ${name} CAN Automatic Discharge Current
    id: can_switch_auto_discharge_current
    optimistic: true
    entity_category: config    

# +--------------------------------------+
# | CAN bus script                       |
# +--------------------------------------+
canbus:
  - platform: esp32_can
    tx_pin: ${can_tx_pin}
    rx_pin: ${can_rx_pin}
    can_id: 4
    bit_rate: 500kbps
    on_frame:
    - can_id: 0x305 # Inverter ACK - SMA/LG/Pylon/Goodwe reply
      then:
        - light.toggle:
            id: blue_led
        - lambda: |-
            id(can_ack_counter) = 0;                              // Reset ACK counter
            id(can_status) = "ON";                                // Set CANBUS Status to ON
            id(canbus_status).publish_state(id(can_status));      // Publish text sensor
            ESP_LOGI("main", "received can id: 0x305 ACK");

interval:
  # activate the limits check
  #- interval: 60s
  #  then:
  #    - lambda: |-
  #        ESP_LOGI("main", "Trigger limit_check_script...");
  #        if (!id(limit_check_script).is_running()) id(limit_check_script).execute();          
        
  - interval: 120s
    then:
      - lambda: id(can_ack_counter) = 0;                          // Reset ACK counter for test inverter ACK
          
  - interval: 100ms
    then:
      # Start CAN Handling
      - if:
          condition:
            lambda: |-
              
              if (id(can_ack_counter) < 20) {                     // Inverter ACK ? => CANBUS ON
                
                id(can_ack_counter)++;                            // CANBUS ACK counter ++
                id(can_msg_counter)++;                            // CANBUS MSG counter ++
                return true;                                      // Condition OK
                
              }
              else if (id(can_status) == "OFF") {                 // CANBUS already OFF ?
                
                return false;                                     // Nothing to do
                
              }
              else {
              
                id(can_status) = "OFF";                           // Set CANBUS Status to OFF
                id(canbus_status).publish_state(id(can_status));  // Publish text sensor
                ESP_LOGI("main", "No rx can 0x305 reply, Inverter not connected/responding...");
                return false;                                     // Condition NOK
                
              }

          then:
            - if:
                condition:
                  lambda: return ((id(can_msg_counter) == 1) & ((${can_protocol} == 1) | (${can_protocol} == 2)));
                then:
                  canbus.send: # Protection Alarms, Warning and Flags ( Pylontech / Goodwe / Seplos )
                    can_id: 0x359
                    data: !lambda |-
                      
                      // +---------------------------+
                      // | JK-BMS errors bitmask     |
                      // +---------------------------+
                      
                      // 0x8B 0x00 0x00: Battery warning message              0000 0000 0000 0000
                      //
                      // Bit 0    Low capacity                                1 (alarm), 0 (normal)    warning
                      // Bit 1    Power tube overtemperature                  1 (alarm), 0 (normal)    alarm
                      // Bit 2    Charging overvoltage                        1 (alarm), 0 (normal)    alarm
                      // Bit 3    Discharging undervoltage                    1 (alarm), 0 (normal)    alarm
                      // Bit 4    Battery over temperature                    1 (alarm), 0 (normal)    alarm
                      // Bit 5    Charging overcurrent                        1 (alarm), 0 (normal)    alarm
                      // Bit 6    Discharging overcurrent                     1 (alarm), 0 (normal)    alarm
                      // Bit 7    Cell pressure difference                    1 (alarm), 0 (normal)    alarm
                      // Bit 8    Overtemperature alarm in the battery box    1 (alarm), 0 (normal)    alarm
                      // Bit 9    Battery low temperature                     1 (alarm), 0 (normal)    alarm
                      // Bit 10   Cell overvoltage                            1 (alarm), 0 (normal)    alarm
                      // Bit 11   Cell undervoltage                           1 (alarm), 0 (normal)    alarm
                      // Bit 12   309_A protection                            1 (alarm), 0 (normal)    alarm
                      // Bit 13   309_A protection                            1 (alarm), 0 (normal)    alarm
                      // Bit 14   Reserved
                      // Bit 15   Reserved
                      //
                      // Examples:
                      // 0x0001 = 00000000 00000001: Low capacity alarm
                      // 0x0002 = 00000000 00000010: MOS tube over-temperature alarm
                      // 0x0003 = 00000000 00000011: Low capacity alarm AND power tube over-temperature alarm
                      
                      // +---------------------------+
                      // | Protection : byte 0 and 1 |
                      // +---------------------------+
                      
                      uint8_t can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};

                      // JK-BMS alarm ?
                      if (id(errors_bitmask).state > 1) {
                         uint16_t jk_errormask = id(errors_bitmask).state;

                         if ((jk_errormask & 0x04) | (jk_errormask & 0x80) | (jk_errormask & 0x400)) {                 // Hight.Voltage.Alarm JK bit 2,7,10
                            can_mesg[0] = 0x02;                                                                        // byte0_bit1 (0x02 = bin 10)
                            id(alarm_status) = "OVP";
                            ESP_LOGI("main", "Hight.Voltage.Alarm JK bit 2,7,10 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x08) | (jk_errormask & 0x800)) {                                         // Low.Voltage.Alarm JK bit 3,11 
                            can_mesg[0] = can_mesg[0] | 0x04;                                                          // byte0_bit2 (0x04 = bin 100)
                            id(alarm_status) = "UVP";
                            ESP_LOGI("main", "Low.Voltage.Alarm JK bit 3,11 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x02) | (jk_errormask & 0x10) | (jk_errormask & 0x100)) {                 // Hight.Temp.Alarm JK bit 1,4,8
                            can_mesg[0] = can_mesg[0] | 0x08;                                                          // byte0_bit3 (0x08 = bin 1000)
                            id(alarm_status) = "OTP";
                            ESP_LOGI("main", "Hight.Temp.Alarm JK bit 1,4,8 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x200)) {                                                                 // Low.Temp.Alarm JK bit 9
                            can_mesg[0] = can_mesg[0] | 0x10;                                                          // byte0_bit4 (0x10 = bin 10000)
                            id(alarm_status) = "UTP";
                            ESP_LOGI("main", "Low.Temp.Alarm JK bit 9 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x40)) {                                                                  // Discharge.Over.Current JK bit 6
                            can_mesg[0] = can_mesg[0] | 0x80;                                                          // byte0_bit7 (0x80 = bin 10000000)
                            id(alarm_status) = "DOCP";
                            ESP_LOGI("main", "Discharge.Over.Current JK bit 6 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x20)) {                                                                  // Charge.Over.Current JK bit 5
                            can_mesg[1] = 0x01;                                                                        // byte1_bit0 (0x01 = bin 1)
                            id(alarm_status) = "COCP";
                            ESP_LOGI("main", "Charge.Over.Current JK bit 5 - can_msg[1] : %x", can_mesg[1]);
                         }
                         if ((jk_errormask & 0x1000) | (jk_errormask & 0x2000)) {                                      // BMS internal error JK bit 12,13
                            can_mesg[1] = can_mesg[1] | 0x08;                                                          // byte1_bit3 (0x08 = bin 1000)
                            id(alarm_status) = "BMS";
                            ESP_LOGI("main", "BMS internal error JK bit 12,13 - can_msg[1] : %x", can_mesg[1]);
                         }
                         if ((jk_errormask & 0x80)) {                                                                  // Cell Imbalance JK bit 7
                            can_mesg[1] = can_mesg[1] | 0x10;                                                          // byte1_bit4 (0x10 = bin 10000)
                            ESP_LOGI("main", "Cell Imbalance JK bit 7 - can_msg[1] : %x", can_mesg[1]);
                         }
                      }
                      // No Alarm
                      else id(alarm_status) = "NoAlarm";

                      // +---------------------------+
                      // | Warning : byte 2 and 3    |
                      // +---------------------------+
                      
                      can_mesg[2] = 0x00;               // byte2 (JK-BMS infos not available)
                      can_mesg[3] = 0x00;               // byte3 (JK-BMS infos not available)
                      
                      // +---------------------------+
                      // | Flags : byte 4 to 7       |
                      // +---------------------------+
                      
                      int batt_mods = ${batt_modules};
                      
                      can_mesg[4] = batt_mods;          // byte4 - Module in parallel
                      can_mesg[5] = 0x00;               // byte5
                      can_mesg[6] = 0x00;               // byte6
                      can_mesg[7] = 0x00;               // byte7 - DIP switches 1,3 10000100 0x84                      
                      
                      ESP_LOGI("main", "send can id: 0x359 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if:
                condition:
                  lambda: return ((id(can_msg_counter) == 1) & ((${can_protocol} == 3) | (${can_protocol} == 4)));
                then:
                  canbus.send: # Protection Alarms and Warning ( SMA / Victron )
                    can_id: 0x35A
                    data: !lambda |-
                      
                      // +---------------------------+
                      // | Protection : byte 0,1,2,3 |
                      // +---------------------------+
                      
                      uint8_t can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};

                      // JK-BMS alarm ?
                      if (id(errors_bitmask).state > 1) {
                         uint16_t jk_errormask = id(errors_bitmask).state;

                         if ((jk_errormask & 0x04) | (jk_errormask & 0x80) | (jk_errormask & 0x400)) {                 // Hight.Voltage.Alarm JK bit 2,7,10
                            can_mesg[0] = 0x04;                                                                        // byte0_bit2 (0x04 = bin 100)
                            id(alarm_status) = "OVP";
                            ESP_LOGI("main", "Hight.Voltage.Alarm JK bit 2,7,10 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x08) | (jk_errormask & 0x800)) {                                         // Low.Voltage.Alarm JK bit 3,11
                            can_mesg[0] = can_mesg[0] | 0x10;                                                          // byte0_bit4 (0x10 = bin 10000)
                            id(alarm_status) = "UVP";
                            ESP_LOGI("main", "Low.Voltage.Alarm JK bit 3,11 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x02) | (jk_errormask & 0x10) | (jk_errormask & 0x100)) {                 // Hight.Temp.Alarm JK bit 1,4,8
                            can_mesg[0] = can_mesg[0] | 0x40;                                                          // byte0_bit6 (0x40 = bin 1000000)
                            id(alarm_status) = "OTP";
                            ESP_LOGI("main", "Hight.Temp.Alarm JK bit 1,4,8 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x200)) {                                                                 // Low.Temp.Alarm JK bit 9
                            can_mesg[1] = 0x01;                                                                        // byte1_bit0 (0x01 = bin 1)
                            id(alarm_status) = "UTP";
                            ESP_LOGI("main", "Low.Temp.Alarm JK bit 9 - can_msg[1] : %x", can_mesg[1]);
                         }
                         if ((jk_errormask & 0x40)) {                                                                  // Discharge.Over.Current JK bit 6
                            can_mesg[1] = can_mesg[1] | 0x40;                                                          // byte1_bit6 (0x40 = bin 1000000)
                            id(alarm_status) = "DOCP";
                            ESP_LOGI("main", "Discharge.Over.Current JK bit 6 - can_msg[1] : %x", can_mesg[1]);
                         }
                         if ((jk_errormask & 0x20)) {                                                                  // Charge.Over.Current JK bit 5
                            can_mesg[2] = 0x01;                                                                        // byte2_bit0 (0x01 = bin 1)
                            id(alarm_status) = "COCP";
                            ESP_LOGI("main", "Charge.Over.Current JK bit 5 - can_msg[2] : %x", can_mesg[2]);
                         }
                         if ((jk_errormask & 0x1000) | (jk_errormask & 0x2000)) {                                      // BMS.Internal.Error JK bit 12,13
                            can_mesg[2] = can_mesg[2] | 0x40;                                                          // byte2_bit6 (0x40 = bin 1000000)
                            id(alarm_status) = "BMS";
                            ESP_LOGI("main", "BMS internal error JK bit 12,13 - can_msg[2] : %x", can_mesg[2]);
                         }
                         if ((jk_errormask & 0x80)) {                                                                  // Cell.Imbalance JK bit 7
                            can_mesg[3] = 0x01;                                                                        // byte3_bit0 (0x01 = bin 1)
                            ESP_LOGI("main", "Cell Imbalance JK bit 7 - can_msg[3] : %x", can_mesg[3]);
                         }
                      }
                      // No Alarm
                      else id(alarm_status) = "NoAlarm";
                      
                      ESP_LOGI("main", "send can id: 0x35A hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if:
                condition:
                  lambda: return id(can_msg_counter) == 2;
                then:
                  canbus.send: # BMS instruction : Charge Volts, Charge Amps, Discharge Amps, Min voltage
                    can_id: 0x351
                    data: !lambda |-
                      
                      // +--------------------------------------+
                      // | Charging Logic                       |
                      // +--------------------------------------+

                      // Warning : information from JK BMS is not available immediately after boot
                      
                      // Alarm : if JK-BMS alarm !
                      if (id(errors_bitmask).state > 1) id(charge_status) = "Alarm";                      
                      
                      
                      ESP_LOGI("main", "Alarm Status : %s", id(alarm_status).c_str());
                      // +--------------------------------------+
                      // | CAN messages                         |
                      // +--------------------------------------+
                      
                      // Byte [00:01] = CVL : Charge Limit Voltage
                      // Byte [02:03] = CCL : Charge Limit Current
                      // Byte [04:05] = DCL : Discharge Limit Current
                      // Byte [06:07] = DVL : Discharge Limit Voltage
                      
                      // We will not influence charging voltage, just keep it as for Inverter to control
                      // Advanced BMS keep voltage stable without any influence at all.
                      id(charging_v) = id(bulk_voltage).state * id(battery_strings).state;          
                      
                      uint8_t can_mesg[8];
                      
                      can_mesg[0] = uint16_t(id(charging_v) * 10) & 0xff;
                      can_mesg[1] = uint16_t(id(charging_v) * 10) >> 8 & 0xff;
                      can_mesg[2] = uint16_t(id(charging_a) * 10) & 0xff;
                      can_mesg[3] = uint16_t(id(charging_a) * 10) >> 8 & 0xff;
                      can_mesg[4] = uint16_t(id(discharging_a) * 10) & 0xff;
                      can_mesg[5] = uint16_t(id(discharging_a) * 10) >> 8 & 0xff;
                      can_mesg[6] = uint16_t(${min_discharge_v} * 10) & 0xff;
                      can_mesg[7] = uint16_t(${min_discharge_v} * 10) >> 8 & 0xff;
                      
                      // Publish text sensor
                      id(charging_status).publish_state(id(charge_status));
                      
                      // Logs
                      ESP_LOGI("main", "send can id: 0x351 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      ESP_LOGI("main", "Charge Status : %s", id(charge_status).c_str());
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if:
                condition:
                  lambda: return id(can_msg_counter) == 3;
                then:
                  canbus.send: # Actual State of Charge (SOC) / State of Health (SOH)
                    can_id: 0x355
                    data: !lambda |-
                     
                      uint8_t can_mesg[8];
                      uint16_t soc = id(report_soc);                      
                      
                      // will need to check this SOH problem                      
                      //int soh = round(((id(charging_cycles).state/${max_cycles})-1)*-100);
                      
                      int soh = id(total_charging_cycle_capacity).state / id(total_battery_capacity_setting).state;                      
                                                                  
                      can_mesg[0] = soc & 0xff;
                      can_mesg[1] = soc >> 8 & 0xff;
                      can_mesg[2] = soh & 0xff;
                      can_mesg[3] = soh >> 8 & 0xff;
                      can_mesg[4] = (soc * 100) & 0xff;
                      can_mesg[5] = (soc * 100) >> 8 & 0xff;
                      can_mesg[6] = uint16_t(id(capacity_remaining_derived).state * 10) & 0xff;
                      can_mesg[7] = uint16_t(id(capacity_remaining_derived).state * 10) >> 8 & 0xff;
                      ESP_LOGI("main", "send can id: 0x355 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if:
                condition:
                  lambda: return id(can_msg_counter) == 4;
                then:
                  canbus.send: # Actual Voltage / Current / Temperature / Cycles (Deye 0x305 ACK)
                    can_id: 0x356
                    data: !lambda |-
                      
                      // Byte [00:01] : Actual Voltage
                      // Byte [02:03] : Actual Current
                      // Byte [04:05] : Actual Temperature
                      // Byte [06:07] : Actual Cycles number (Sofar)

                      uint8_t can_mesg[8];
                      can_mesg[0] = uint16_t(id(total_voltage).state * 100) & 0xff;
                      can_mesg[1] = uint16_t(id(total_voltage).state * 100) >> 8 & 0xff;
                      can_mesg[2] = int16_t(id(current).state * 10) & 0xff;
                      can_mesg[3] = int16_t(id(current).state * 10) >> 8 & 0xff;
                      can_mesg[4] = int16_t(max(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) & 0xff;
                      can_mesg[5] = int16_t(max(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) >> 8 & 0xff;
                      can_mesg[6] = uint16_t(id(charging_cycles).state) & 0xff;
                      can_mesg[7] = uint16_t(id(charging_cycles).state) >> 8 & 0xff;    
                      ESP_LOGI("main", "send can id: 0x356 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if:
                condition:
                  lambda: return ((id(can_msg_counter) == 5) & ((${can_protocol} == 1) | (${can_protocol} == 2)));
                then:
                  canbus.send: # Request flag to Enable/Disable: Charge, Discharge ( Pylontech / Goodwe / Seplos )
                    can_id: 0x35C
                    data: !lambda |-
                      uint8_t can_mesg[2];
                      can_mesg[0] = 0x00;
                      can_mesg[1] = 0x00;
                      
                      // Bit 7 : Charge enable
                      if ((id(charging_switch).state) & (id(switch_charging).state))
                         can_mesg[0] = 0x80;
                      
                      // Bit 6 : Discharge enable
                      if ((id(discharging_switch).state) & (id(switch_discharging).state))
                         can_mesg[0] = can_mesg[0] | 0x40;
                                            
                      ESP_LOGI("main", "send can id: 0x35C hex: %x %x", can_mesg[0], can_mesg[1]);
                      return {can_mesg[0], can_mesg[1]};
                      
            - if:
                condition:
                  lambda: return (id(can_msg_counter) == 6);
                then:
                  canbus.send: # Actual Max Cell Temp, Min Cell Temp, Max Cell V, Min Cell V ( Pylontech / Goodwe / Seplos/ LuxPower )
                    can_id: 0x373
                    data: !lambda |-
                      int max_cell_voltage_i = id(max_cell_voltage).state * 1000.0;
                      int min_cell_voltage_i = id(min_cell_voltage).state * 1000.0;
                      uint8_t can_mesg[7];
                      can_mesg[0] = min_cell_voltage_i & 0xff;
                      can_mesg[1] = min_cell_voltage_i >> 8 & 0xff;            
                      can_mesg[2] = max_cell_voltage_i & 0xff;
                      can_mesg[3] = max_cell_voltage_i >> 8 & 0xff;            
                      can_mesg[4] = int16_t(max(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) & 0xff;
                      can_mesg[5] = int16_t(max(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) >> 8 & 0xff;
                      can_mesg[6] = int16_t(min(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) & 0xff;
                      can_mesg[7] = int16_t(min(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) >> 8 & 0xff;
                      ESP_LOGI("main", "send can id: 0x70 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if:
                condition:
                  lambda: return ((id(can_msg_counter) == 6) & (${can_protocol} == 2));
                then:
                  - canbus.send: # Actual Max Cell Temp ID, Min Cell Temp ID, Max Cell V ID, Min Cell ID ( Pylontech / Goodwe / Seplos )
                      can_id: 0x371
                      data: !lambda |-
                        
                        // Byte [00:01] : Max cell temperature ID
                        // Byte [02:03] : Min cell temperature ID
                        // Byte [04:05] : Max cell voltage ID
                        // Byte [06:07] : Min cell voltage ID
                        
                        uint8_t can_mesg[8];

                        // Min-Max Temp. Sensor ID ?
                        if (id(temperature_sensor_1).state >= id(temperature_sensor_2).state){
                          can_mesg[0] = 0x01;
                          can_mesg[2] = 0x02;
                        }
                        else {
                          can_mesg[0] = 0x02;
                          can_mesg[2] = 0x01;
                        }
                        
                        can_mesg[1] = 0x00;
                        can_mesg[3] = 0x00;
                        can_mesg[4] = uint16_t(id(max_voltage_cell).state) & 0xff;
                        can_mesg[5] = uint16_t(id(max_voltage_cell).state) >> 8 & 0xff;
                        can_mesg[6] = uint16_t(id(min_voltage_cell).state) & 0xff;
                        can_mesg[7] = uint16_t(id(min_voltage_cell).state) >> 8 & 0xff;
                        ESP_LOGI("main", "send can id: 0x371 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                        return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                        
            - if:
                condition:
                  lambda: return ((id(can_msg_counter) == 7) & (${can_protocol} == 4));
                then:
                  - canbus.send: # Battery modules information ( Victron )
                      can_id: 0x372
                      data: !lambda |-
                        
                        // Byte [00:01] : Nbr. of battery modules online
                        // Byte [02:03] : Nbr. of modules blocking charge
                        // Byte [04:05] : Nbr. of modules blocking discharge
                        // Byte [06:07] : Nbr. of battery modules offline
                        
                        uint8_t can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};
                        can_mesg[0] = 0x01;

                        ESP_LOGI("main", "send can id: 0x372 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                        return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};

            - if:
                condition:
                  lambda: return ((id(can_msg_counter) == 8) & (${can_protocol} == 4));
                then:
                  canbus.send: # Actual Min Cell V, Max Cell V, Min Cell Temp (Kelvin), Max Cell Temp (Kelvin) ( Victron )
                    can_id: 0x373
                    data: !lambda |-
                      
                      // Byte [00:01] : Min cell voltage
                      // Byte [02:03] : Max cell voltage
                      // Byte [04:05] : Min cell temperature
                      // Byte [06:07] : Max cell temperature
                      
                      int min_cell_voltage_i = id(min_cell_voltage).state * 1000.0;
                      int max_cell_voltage_i = id(max_cell_voltage).state * 1000.0;
                      int min_temp_kelvin = min(id(temperature_sensor_1).state, id(temperature_sensor_2).state) + 273.15;
                      int max_temp_kelvin = max(id(temperature_sensor_1).state, id(temperature_sensor_2).state) + 273.15;
                      
                      uint8_t can_mesg[8];
                      can_mesg[0] = min_cell_voltage_i & 0xff;
                      can_mesg[1] = min_cell_voltage_i >> 8 & 0xff;
                      can_mesg[2] = max_cell_voltage_i & 0xff;
                      can_mesg[3] = max_cell_voltage_i >> 8 & 0xff;
                      can_mesg[4] = min_temp_kelvin & 0xff;
                      can_mesg[5] = min_temp_kelvin >> 8 & 0xff;
                      can_mesg[6] = max_temp_kelvin & 0xff;
                      can_mesg[7] = max_temp_kelvin >> 8 & 0xff;
                      
                      ESP_LOGI("main", "send can id: 0x373 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if:
                condition:
                  lambda: return ((id(can_msg_counter) == 8) & (${can_protocol} == 4));
                then:
                  - canbus.send: # Min cell voltage ID [ASCII] ( Victron )
                      can_id: 0x374
                      data: !lambda |-
                        
                        int cell_id = id(min_voltage_cell).state;

                        ESP_LOGI("main", "send can id: 0x374 [ASCII] Min cell voltage ID : %i", cell_id);

                        if (cell_id == 1) return {0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 2) return {0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 3) return {0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 4) return {0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 5) return {0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 6) return {0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 7) return {0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 8) return {0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 9) return {0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 10) return {0x31, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 11) return {0x31, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 12) return {0x31, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 13) return {0x31, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 14) return {0x31, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 15) return {0x31, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 16) return {0x31, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else return {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

            - if:
                condition:
                  lambda: return ((id(can_msg_counter) == 8) & (${can_protocol} == 4));
                then:
                  - canbus.send: # Max cell voltage ID [ASCII] ( Victron )
                      can_id: 0x375
                      data: !lambda |-
                        
                        int cell_id = id(max_voltage_cell).state;

                        ESP_LOGI("main", "send can id: 0x375 [ASCII] Max cell voltage ID : %i", cell_id);

                        if (cell_id == 1) return {0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 2) return {0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 3) return {0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 4) return {0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 5) return {0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 6) return {0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 7) return {0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 8) return {0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 9) return {0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 10) return {0x31, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 11) return {0x31, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 12) return {0x31, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 13) return {0x31, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 14) return {0x31, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 15) return {0x31, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 16) return {0x31, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else return {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

            - if:
                condition:
                  lambda: return ((id(can_msg_counter) == 8) & (${can_protocol} == 4));
                then:
                  - canbus.send: # Min cell temperature ID [ASCII] ( Victron )
                      can_id: 0x376
                      data: !lambda |-
                        
                        // Min Temp. Sensor ID ?
                        if (id(temperature_sensor_1).state >= id(temperature_sensor_2).state){
                          ESP_LOGI("main", "send can id: 0x376 [ASCII] Min Temp. Sensor ID : 2");
                          return {0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        }
                        else {
                          ESP_LOGI("main", "send can id: 0x376 [ASCII] Min Temp. Sensor ID : 1");
                          return {0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        }

            - if:
                condition:
                  lambda: return ((id(can_msg_counter) == 8) & (${can_protocol} == 4));
                then:
                  - canbus.send: # Max cell temperature ID [ASCII] ( Victron )
                      can_id: 0x377
                      data: !lambda |-
                        
                        // Max Temp. Sensor ID ?
                        if (id(temperature_sensor_1).state >= id(temperature_sensor_2).state){
                          ESP_LOGI("main", "send can id: 0x377 [ASCII] Max Temp. Sensor ID : 1");
                          return {0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        }
                        else {
                          ESP_LOGI("main", "send can id: 0x377 [ASCII] Max Temp. Sensor ID : 2");
                          return {0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        }

            - if:
                condition:
                  lambda: return (id(can_msg_counter) == 9);
                then:
                  - canbus.send: # Battery Installed Capacity Ah ( Victron, Sol-Ark, Luxpower )
                      can_id: 0x379
                      data: !lambda |-
                        uint8_t can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};
                        can_mesg[0] = uint16_t(id(total_battery_capacity_setting).state) + uint16_t(id(parrallel_packs_capacity_ah).state) & 0xff;
                        can_mesg[1] = uint16_t(id(total_battery_capacity_setting).state) + uint16_t(id(parrallel_packs_capacity_ah).state) >> 8 & 0xff;
                        
                        ESP_LOGI("main", "send can id: 0x379 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                        return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                        
            - if:
                condition:
                  lambda: return ((id(can_msg_counter) == 10) & (${can_protocol} == 4));
                then:
                  - canbus.send: # Product identification [ASCII] ( Victron )
                      can_id: 0x382
                      data: !lambda |-
                        ESP_LOGI("main", "send can id: 0x382 [ASCII] Product : JK-BMS");
                        return {0x4A, 0x4B, 0x2D, 0x42, 0x4D, 0x53, 0x00, 0x00}; // JK-BMS

            - if:
                condition:
                  lambda: return ((id(can_msg_counter) == 11) & ((${can_protocol} == 3) | (${can_protocol} == 4)));
                then:
                  - canbus.send: # Battery information ( SMA, Victron )
                      can_id: 0x35F
                      data: !lambda |-
                        
                        //                SMA                 Victron
                        // Byte [00:01] : Bat-Type            Product ID
                        // Byte [02:03] : BMS Version         Firmware version (1.16 => HEX [01:10])
                        // Byte [04:05] : Bat-Capacity        Available Capacity Ah
                        // Byte [06:07] : Manufacturer ID     Hardware version
                        
                        uint8_t can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};
                        can_mesg[2] = 0x01;
                        can_mesg[3] = 0x10;
                        can_mesg[4] = uint16_t(id(total_battery_capacity_setting).state) & 0xff;
                        can_mesg[5] = uint16_t(id(total_battery_capacity_setting).state) >> 8 & 0xff;
                        
                        ESP_LOGI("main", "send can id: 0x35F hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                        return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                        
            - if:
                condition:
                  lambda: return id(can_msg_counter) == 12;
                then:
                  - canbus.send:
                      can_id: 0x35E # Manufacturer name
                      data: !lambda |-
                        if (${can_bms_name} == 1){
                           ESP_LOGI("main", "send can id: 0x35E ASCII : PYLON");
                           return {0x50, 0x59, 0x4C, 0x4F, 0x4E, 0x20, 0x20, 0x20}; // PYLON ( recognized by Deye, display PYLON name and SOH )
                        }
                        else if (${can_bms_name} == 2){
                           ESP_LOGI("main", "send can id: 0x35E ASCII : GOODWE");
                           return {0x47, 0x4F, 0x4F, 0x44, 0x57, 0x45, 0x20, 0x20}; // GOODWE
                        }
                        else if (${can_bms_name} == 3){
                           ESP_LOGI("main", "send can id: 0x35E ASCII : SHEnergy");
                           return {0x53, 0x48, 0x45, 0x6E, 0x65, 0x72, 0x67, 0x79}; // SHEnergy (SEPLOS)
                        }
                    # Reset counter
                  - lambda: id(can_msg_counter) = 0;
